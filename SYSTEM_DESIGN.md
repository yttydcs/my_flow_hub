# MyFlowHub 系统设计文档

## 1. 设计理念

MyFlowHub 是一个为物联网设备设计的分布式、层级化的消息与数据同步系统。其核心理念是将所有设备（从高性能服务器到嵌入式节点）连接成一个抽象网络，实现设备间的可靠通信、权限管理和双向数据绑定。

- **分层架构**: 系统分为“中枢”、“中继”、“节点”三个角色，以适应不同的部署环境和网络条件。
- **角色包容**: 高级角色包含低级角色的所有功能。中枢是特殊的中继，中继是特殊的节点。
- **数据驱动**: 以“变量池”为核心，实现设备状态与云端数据的双向同步，类似前端框架中的响应式模型。
- **自治能力**: “中继”在与“中枢”断开连接时，能够独立管理其局部网络，保证核心功能可用。

## 2. 系统架构

  <!-- 占位符，后续可以替换为实际的架构图 -->

### 2.1. 统一的服务端角色

为了实现最大的灵活性和架构一致性，我们不再从软件层面区分“中枢”和“中继”。它们是**同一种服务端软件**的不同配置实例。

- **服务端 (Server)**
  - **职责**: 接受下级节点的连接，管理其认证、权限和消息路由。同时，它可以作为客户端连接到一个上级服务端。
  - **作为中枢 (Hub)**: 当一个服务端实例**没有配置上级**时，它就是网络的根，即“中枢”。它拥有全局的最终决定权。
  - **作为中继 (Relay)**: 当一个服务端实例**配置了上级**时，它就是“中继”。它负责管理其下级网络，并将其状态和消息向上传递。
  - **部署**: 可以部署在云端、边缘服务器或任何有足够资源的本地设备上。

- **节点 (Node)**
  - **职责**: 网络的叶子，作为数据的生产者和消费者。它**必须连接到一个服务端**（中继或中枢）。
  - **部署**: 嵌入式设备、PC应用、手机App等。

### 2.2. 技术选型

| 组件 | 技术 | 理由 |
| :--- | :--- | :--- |
| **中枢/中继服务端** | **Go 语言** | **用户指定**。Go 的并发模型 (Goroutine) 和网络库非常适合构建高性能、高并发的后台服务，与本项目需求完美契合。 |
| **数据库** | **PostgreSQL** | **用户指定**。功能强大、稳定可靠的开源关系型数据库，支持 JSONB 等高级数据类型，便于存储半结构化的设备数据。 |
| **通信协议** | **WebSocket + 自定义消息格式 (JSON)** | **不使用 MQTT**。WebSocket 提供持久化的双向通信信道，延迟低，适合实时控制和数据上报。JSON 格式通用性好，易于调试和跨语言实现。 |
| **节点 (嵌入式)** | C/C++, MicroPython, Rust | 取决于具体硬件资源。需要选择支持 TCP/IP 和 WebSocket 客户端库的语言。 |
| **部署** | Docker, Kubernetes (可选) | 使用容器化技术简化部署和管理流程，尤其是在中枢和中继的部署上。 |

## 3. 核心功能设计

### 3.1. 变量池 (Variable Pool)

- **概念**: 每个设备拥有一个独立的命名空间，用于存储其状态变量。这是一个键值对集合。
- **数据类型**: 支持 `string`, `number`, `boolean`, `object`, `array` 等常见类型。
- **访问控制**:
  - 设备默认只能读写自己的变量。
  - 访问其他设备的变量需要通过其上级（中继或中枢）进行权限验证。
  - 权限规则将在数据库中定义和管理。
- **数据同步（双向绑定）**:
  - **上行同步**: 节点内部数据变化时，主动向上级发送 `var_update` 消息。
  - **下行通知**: 当一个设备的变量在服务端被修改时（例如被另一个设备通过 `var_update` 修改），服务端会**立即检查**该变量的所属节点是否在线。如果在线，服务端会主动向其推送一条 `var_notify` 消息，其中包含变更后的变量数据。离线节点则会被忽略。
  - **上线同步**: 当一个节点成功连接并认证后，服务端会**立即从数据库中获取**该节点名下的所有变量，并将其打包成一条 `var_notify` 消息，作为“初始状态”一次性推送给该节点。这确保了节点在每次上线时都能获得其变量池的最新、最完整的状态。

### 3.2. 通信与状态管理

- **连接**: 任何设备（节点或中继）启动后，都会向其预设的上级服务端地址发起 WebSocket 连接请求。
- **认证与注册**: 采用动态注册和凭证认证机制（详见 `COMMUNICATION_PROTOCOL.md`）。
- **级联心跳与状态同步**:
  - **核心机制**: 每个服务端负责维护其所有直连下级的状态（如在线状态、关键指标等）。
  - **心跳聚合**: 当一个服务端（中继）向上级发送心跳时，其心跳包内不仅包含自身的状态，还**聚合了其下级网络的状态摘要**。
  - **增量更新**: 为了节省带宽，心跳包默认只包含自上次心跳以来**状态发生变化的**下级节点信息。如果网络状态稳定，心跳包会非常小。
  - **管理基础**: 这种级联的状态同步是网络管理的基础。例如，一个中枢可以通过分析心跳数据，了解整个网络的拓扑和健康状况。一个中继决定“踢出”某个节点，本质上就是停止维护其状态，并不再将其状态向上级汇报。

## 4. 下一步

1.  **编写通信协议规范 (`COMMUNICATION_PROTOCOL.md`)**: 定义详细的消息格式、类型和交互流程。
2.  **数据库表结构设计**: 设计用于存储设备、权限和变量数据的表。
3.  **开发概念验证 (PoC)**: 使用 Go 实现一个简化的中枢和节点模拟器，验证核心通信和数据同步逻辑。
